---
layout: post
title: '计算机组成原理'
subtitle:   "计算机组成原理复习"
date: 2020-01-03
author: biubiu
header-img: 'assets/img/pro9.jpg'
catalog: true
tags: C++ test
---
## 计算机组成原理复习

### 一、流水线

数据通路流水线化

目标：保证(几乎) 1.0 的CPI, 同时提高时钟速率

#### 	1.流水线的性能

时钟周期等于最长阶段所花时间为：$2ns$

每条lw指令的执行时间为： $2nsx5=10ns$

N条指令的执行时间为：$(5+(N-1))x2ns$

在N很大时约为$2Nns$，比串行方式提高约 4 倍,若各阶段操作均衡(例如，各阶段都是$2ns$，则串行需$10Nns$，流水线仍为$2Nns$，加速为5倍。

#### 	2.结构冒险

定义：把一个功能部件同时被多条指令使用的现象

解决方式：

•每个功能部件每条指令只能用一次（如：写口不能用两次或以上）

•每个功能部件必须在相同的阶段被使用（如：写口总是在第五阶段被使用）

•另流水线上每条指令都有相同多个阶段

•寄存器的读取在下降沿触发，写入在上升沿触发可解决寄存器的结构冒险

•指令存储器和数据存储器使用两个不同存储器

#### 	3.控制冒险

定义：转移分支指令(Branch)引起的“延迟”现象

![image-20200103162312958](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200103162312958.png)

Jump在ID阶段被判断处理需要阻塞一个周期	

关于beq，bne等分支语句：

1）将分支判断比较和有效地址的运算放在ID阶段，这样只需要延迟一个时钟周期

2）若放在ID阶段，如果使用的数据与上一个指令有冲突，则需要延迟一个周期

##### 		分支预测

1）总假设分支不发生：

​	遇到分支指令仍然按照正常的流程取指令,如果在流水线后期确实分支发生,则阻塞并取消已进入流水线指令

2）总假定分支会发生

​	无论如何都加一个阻塞，没用

3）动态预测：利用运行时的信息进行动态预测（使用分支历史记录表BHT）

​	一位预测：

![image-20200103170023007](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200103170023007.png)

![image-20200103170535152](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200103170535152.png)

​	两位预测：

基本思想：只有两侧预测错误才改变方向

•11状态时预测发生（强转移），实际不发生时，转到状态10（弱转移），下次仍预测为发生，如果再次预测错误（实际不发生），才使下次预测调整为不发生00

![image-20200103170602384](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200103170602384.png)

![image-20200103170724178](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200103170724178.png)

##### 	延迟分支

基本思想：

把分支指令前面的与分支指令无关的指令调到分支指令后面执行，以填充延迟时间片

有三种方式：

![image-20200103171528801](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200103171528801.png)



#### 	4.数据冒险

定义：流水线使原先有先后顺序的指令同时处理，当出现某些指令的组合时，可能会导致指令使用了错误的数据。

![image-20200103162435567](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200103162435567.png)

类型：

​	1）写入寄存器为alu结果：可以通过转发解决

​	2）写入寄存器为DM读出的内容：随后指令需要被阻塞一个时钟周期

解决方法：

​	转发：把数据从流水段寄存器中直接取到ALU的输入端

![image-20200103163307838](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200103163307838.png)

注意：

load指令就算使用转发解决仍然需要延迟执行一条指令，这种load指令和随后指令间的数据冒险，称为“装入使用数据冒险“(load- use Data Hazard)

### 二、存储器

#### 1.存储器的分类

![image-20200103174055870](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200103174055870.png)

静态随机存取存储器SRAM

动态随机存取存储器DRAM

#### 2.局部性原则

​	1）时间局部性

​	最近访问的数据项很可能马上再次被访问，如循环指令

​	2）空间局部性

​	最近访问数据项的邻近数据项可能很快也将被访问，如数组

#### 3.存储层次

#### 	![image-20200103174504660](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200103174504660.png)

原理：

构成了一个统一管理、统一调度，并且对用户来说透明的一体化的存储器系统，即三级结构的存储器系统。

为解决主存容量不足，借助硬盘上的虚拟存储空间

未解决访存不快时，在两者之间增加了CACHE

![image-20200103174644804](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200103174644804.png)

#### 4.$Cache$

##### 		1）基本结构

存储结构：保存数据，存取数据，一般采用SRAM构成。以Block（若干字）为单位；

地址结构：地址比较机制，每一个块有一个地址标记Tag

替换机制：记录块的使用情况，替换情况，有效位记录块中的数据是否有效

##### 		2）相关术语

数据块（block）：Cache与主存的基本划分单位，也是主存与Cache一次交换数据的最小单位，由多个字节（字）组成，取决于Cache从主存一次读写操作所能完成的数据字节数。也表明主存与Cache之间局部总线的宽度。

标记（Tag）：Cache每一数据块有一个标记字段，用来保存该数据块对应的主存数据块的地址信息。

有效位（valid）：Cache中每一Block有一个有效位，用于指示相应数据块中是否包含有效数据。

行（line）：Cache中 一个block及其 tag、valid bit构成1行。

组（set）：若干块(Block)构成一个组，地址比较一般能在组内各块间同时进行。

路（way）：Cache相关联的等级，每一路具有独立的地址比较机构，各路地址比较能同时进行（一般与组结合），路数即指一组内的块数。

命中（hit）：CPU要访问的数据在Cache中。

缺失（miss）：CPU要访问的数据不在Cache中 。

##### 		3）直接映射Cache

主存中每一个块只能映射到某一固定的Cache块当中

$K=j $  mod    $cache中块数$

K:   Cache的块号码

j：主存的块号码

###### 	Cache细分：

| 标记位    | 有效位 | 数据页           |
| --------- | ------ | ---------------- |
| Tag的位数 | 1位    | 块的大小位数=8*m |

###### 	地址细分：

| 标记位    | 页号               | 页内地址            |
| --------- | ------------------ | ------------------- |
| Tag的位数 | log（Cache中页数） | log（页中的字节数） |

优点：实现简单，只需利用主存地址中的区地址，与块地址对应的Cache块中Tag 进行1次比较，即可确定是否命中

缺点：映射关系不灵活，因每个主存块只能固定地对应某个确定的Cache块，会出现Cache有很多空闲，但新块不能直接写入而需要替换的现象，Cache空间的利用不充分

##### 		4）全相联

➢主存分为若干Block，Cache按同样大小分成若干Block，

➢Cache中的Block数目显然比主存的Block数少得多。

➢主存中的某一Block可以映射到Cache中的任意一Blcok。

寻找方式：

根据Tag对Cache中每一页进行匹配，如相同则选中

​	优点：

-对Cache的使用可以有最大的灵活性：

-如Cache空闲，能确保新块直接写入

-如Cache已满，也可方便地选择一个Cache块来替换

​	缺点：

在执行Cache读写操作时，主存地址中的块地址要与 Cache中所有Tag都比较后，才能知晓是否不命中

由于实现这一比较操作的电路过多过于复杂，实现成本太高而难以实用，因此仅在Cache容量很小时采用

##### 		5）组相联（Associative Cache）

​	映射关系：Cache 分成 K 组，每组分成 L 块（L即为路数）；主存的块 J

​	以下列原则映射到 Cache 的组 I 中的任何一块。

​		I = J mod K

​	实际上主存与Cache都分成 K 组，主存每一组内的块数与Cache一组内的块数不一致，主存组M内的某一块只能映射到Cache组M内，但可以是组M内的任意一块。

| **组内块地址** **(tag)** | 组地址way | 块内偏移index |
| ------------------------ | --------- | ------------- |
|                          |           |               |

##### 		6)Cache性能

CPU执行时间=（CPU时钟周期数+存储器停顿周期数）*时钟周期时间

存储器停顿周期数=缺失次数*缺失代缴

​				=指令数*存储器访问次数/指令数 *缺失率 *缺失代价

•AMAT = Hit time + Miss rate × Miss penalty

​			=命中时间 + 缺失率  *  缺失代价

![image-20200103194930103](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200103194930103.png)

##### 		7)缺失替换

1.$LRU$最近最少使用策略

原则：将近期最少使用的块替换出去（使用计数器）

2.$LFU$最久未被访问策略

原则：其核心思想是“如果数据过去被访问多次，那么将来被访问的频率也更高”。

图反了

![image-20200103201334119](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200103201334119.png)

3.$FIFO$先进先出策略

原则：总是将最先调入的Cache的块替换出去

4.随机替换

![image-20200103201527600](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200103201527600.png)

##### 		8）写操作

1.写回法

命中时：

只修改cache的内容不立即写入主存，只当此行被换出时才写回主存。

未命中：

写回法的处理是为包含欲写字的主存块在cache分配一行，将此块整个拷贝到Cache后在cache中对其进行修改；拷贝主存块时虽已读访问到主存，但此时并不对主存块修改，统一地将主存写修改操作留待换出时进行。

优缺点：

写cache与写主存分开进行方式可显著减少写主存次数，但写回法存在cache/主存不一致性的隐患。

2.写直达法（全写法）

命中时：

cache与主存同时发生写修改。这种策略显然较好地维护了cache与主存的内容一致性

未命中时：

Ø  一种是取主存块到cache并为它分配一个行位置，

   称为WTWA法(Write-Through-with-Write-Allocate）；

Ø  另一种是不取主存块到cache, 称为WTNWA法

   （Write-Through-with．NO-Write-Allocate）。

##### 	9）降低缺失率

1.强制性失效：当第一次访问一个块时，该块不在 Cache中，需从下一级存储器中调入Cache， 这就是强制性失效。  

​	增加块大小

2.容量失效：如果程序执行时所需的块不能全部调 入Cache中，则当某些块被替换后，若又重新被访问，就会发生失效。这种失效称为容量失效。

​	增加容量

3.冲突失效：在组相联或直接映象Cache中，若太多的块映象到同一组(块)中，则会出现该组 中某个块被别的块替换(即使别的组或块有空闲位置)，然后又被重新访问的情况。这就是发生了冲突失效。(碰撞失效，干扰失效)

​	提高相联度

![image-20200103210124877](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200103210124877.png)

### 三、虚拟存储器

➢程序运行时，内存管理采用交换机制（硬件和操作系统实现），进程保存在辅存中，进程执行时，只将其活跃部分调入内存（局部性原理）。此时主存可以视为辅存的“高速缓存”

➢这样一种把主存当做辅助存储器的高速缓存的技术，称为虚拟存储器（virtual memory）技术

##### 	1）段式管理

![image-20200103211523797](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200103211523797.png)

| 用户号 | 虚页号 | 页内偏移 |
| ------ | ------ | -------- |
|        | 实页号 | 页内偏移 |

在页表当中从虚页号那一行当中找到对应实页号，实页号+页内偏移便是实际地址

页表结构：

| 装入位 | 修改位 | 替换控制位 | 其他 | 实页号 |
| ------ | ------ | ---------- | ---- | ------ |
|        |        |            |      |        |

##### 	2）$TLB$（快速地址转换技术）

​	是—个专用的高速缓冲器，用于存放近期经常使用的页表项(Page Table Entry，PTE)。根据程序的局部性原理，它所用的页表项也是聚集的。

​	这样，大多数访存都可以通过TLB快速地完成虚--实地址转换，只有偶尔在TLB不命中时，才需要去访问主存中的页表。

类似于Cache